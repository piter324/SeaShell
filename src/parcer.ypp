%{
  #include <bits/stdc++.h>
  #include <iostream>
  
  #include "src/structures/RedirectionExpr.h"
  #include "src/structures/VariableAssignment.h"
  #include "src/structures/VariableCall.h"
  #include "src/structures/Program.h"
  #include "src/structures/PipeExpr.h"
  #include "src/structures/Node.h"
  #include "src/structures/Identifier.h"
  #include "src/structures/Command.h"
  #include "src/structures/BackTickExpr.h"

  extern int yylex();
  extern int yyparse();
  extern "C" FILE *yyin;
  extern "C" int errors;
  void yyerror (char const *s);
  int errors = 0;
  using namespace std;
  #define YYSTYPE char*
%}
// Tokens

%start program

%union {
    BackTickExpr* backtick_expr;
    Command* command;
    Identifier* ident;
    Node* node;
    PipeExpr* pipe_expr;
    Program* program;
    RedirectionExpr* redir_expr;
    VariableAssignment* var_ass;
    VariableCall* var_call;
}

%token LAND LOR BAND BOR
%token ASSIGN SC EXPORT SM GR
%token SQ_LITERAL DQ_LITERAL BS_LITERAL
%token IDENTIFIER VARIABLE

%%

program       : /* blank */ {  }
              | program command { auto commands = $1->getCommands(); commands.push_back($2);
                  $1->setCommands(commands); }
              | program pipeline { auto commands = $1->getCommands(); commands.push_back($2);
                  $1->setCommands(commands); }
              | program assignment { auto commands = $1->getCommands(); commands.push_back($2);
                  $1->setCommands(commands); }
              | program redirection { auto commands = $1->getCommands(); commands.push_back($2);
                  $1->setCommands(commands); }
              | program SC { $$ = $1; }
              ;

assignment    : identifier ASSIGN assignable { $$ = new VariableAssignment($1->getIdentifier(), $3); 
                  /* Work with variable values */ }
              ;

redirection   : redirection GR assignable { $1->setOutput($3); $$ = $1; }
              | redirection SM assignable { $1->setInput($3); $$ = $1; }
              | command GR assignable { $$ = new RedirectionExpr($1, nullptr, $3); }
              | command SM assignable { $$ = new RedirectionExpr($1, $3, nullptr); }
              ;

pipeline      : pipeline BOR command { auto pipes = $1->getPipes(); pipes.push_back($3); 
                  $1->setPipes(pipes); $$ = $1; }
              : command BOR command { std::vector<Node*> pipes(); pipes.push_back($1);pipes.push_back($3);
                  $$ = PipeExpr(pipes); }
              ;

command       : command assignable { auto args = $1->getArguments(); args.push_back($2);
                  $1->setArguments(args); $$ = $1; }
              | assignable { std::vector<Node*> args(); 
                  $$ = new Command($1, args); }
              ;

assignable    : backtick_expr { $$ = $1; }
              | identifier { $$ = $1; }
              | variable_call { $$ = $1; }
              ;

backtick_expr : BT program BT { $$ = new BackTickExpr($1); }
              ;

identifier    : IDENTIFIER { $$ = new Identifier($1); }
              ;

variable_call : VARIABLE { $$ = new VariableCall($1); }
              ;
%%

void yyerror (char const *s)
{
    errors++;
	  printf("Error: %s\n", s);
}

int main(int argc, char *argv[])
{
  	do {
  		  yyparse();
  	} while (!feof(yyin));
  	return 0;
}
