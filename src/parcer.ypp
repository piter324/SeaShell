%{
  #include <bits/stdc++.h>
  #include <iostream>
  
  #include "structures/RedirectionExpr.h"
  #include "structures/VariableAssignment.h"
  #include "structures/VariableCall.h"
  #include "structures/Program.h"
  #include "structures/PipeExpr.h"
  #include "structures/Node.h"
  #include "structures/Identifier.h"
  #include "structures/Command.h"
  #include "structures/BackTickExpr.h"

  extern int yylex();
  extern int yyparse();
  extern "C" FILE *yyin;
  extern "C" int errors;
  void yyerror (char const *s);
  int errors = 0;
  using namespace std;
  #define YYSTYPE char*
%}
// Tokens

%union {
    char* sval;
    BackTickExpr* backtick_expr;
    Command* command;
    Identifier* ident;
    Assignable* assign;
    Node* node;
    PipeExpr* pipe_expr;
    Program* program;
    RedirectionExpr* redir_expr;
    VariableAssignment* var_ass;
    VariableCall* var_call;
}

%start program
%token LAND LOR BAND BOR
%token ASSIGN SC SM GR BT
%token<sval> IDENTIFIER VARIABLE


%type <program> program
%type <command> command
%type <assign> assignable
%type <var_ass> assignment
%type <redir_expr> redirection
%type <pipe_expr> pipeline
%type <backtick_expr> backtick_expr
%type <ident> identifier
%type <var_call> variable_call 

%%

program       : /* blank */ {  }
              | program command { auto commands = $1->getCommands(); commands.push_back($2);
                  $1->setCommands(commands); }
              | program pipeline { auto commands = $1->getCommands(); commands.push_back($2);
                  $1->setCommands(commands); }
              | program assignment { auto commands = $1->getCommands(); commands.push_back($2);
                  $1->setCommands(commands); }
              | program redirection { auto commands = $1->getCommands(); commands.push_back($2);
                  $1->setCommands(commands); }
              | program SC { $$ = $1; }
              ;

assignment    : identifier ASSIGN assignable { $$ = new VariableAssignment($1->getIdentifier(), $3); 
                  /* Work with variable values */ }
              ;

redirection   : redirection GR assignable { $1->setOutput($3); $$ = $1; }
              | redirection SM assignable { $1->setInput($3); $$ = $1; }
              | command GR assignable { $$ = new RedirectionExpr($1, nullptr, $3); }
              | command SM assignable { $$ = new RedirectionExpr($1, $3, nullptr); }
              ;

pipeline      : pipeline BOR command { auto pipes = $1->getPipes(); pipes.push_back($3); 
                  $1->setPipes(pipes); $$ = $1; }
              | command BOR command { std::vector<Node*> pipes(); pipes.push_back($1);pipes.push_back($3);
                  $$ = PipeExpr(pipes); }
              ;

command       : command assignable { auto args = $1->getArguments(); args.push_back($2);
                  $1->setArguments(args); $$ = $1; }
              | assignable { std::vector<Node*> args(); 
                  $$ = new Command($1, args); }
              ;

assignable    : backtick_expr { $$ = $1; }
              | identifier { $$ = $1; }
              | variable_call { $$ = $1; }
              ;

backtick_expr : BT program BT { $$ = new BackTickExpr($2); }
              ;

identifier    : IDENTIFIER { $$ = new Identifier(string($1); }
              ;

variable_call : VARIABLE { $$ = new VariableCall(string($1)); }
              ;
%%

void yyerror (char const *s)
{
    errors++;
	  printf("Error: %s\n", s);
}

int main(int argc, char *argv[])
{
  	do {
  		  yyparse();
  	} while (!feof(yyin));
  	return 0;
}
