%code requires {
  #include "structures/RedirectionExpr.h"
  #include "structures/VariableAssignment.h"
  #include "structures/VariableCall.h"
  #include "structures/Program.h"
  #include "structures/PipeExpr.h"
  #include "structures/Node.h"
  #include "structures/Identifier.h"
  #include "structures/Command.h"
  #include "structures/BackTickExpr.h"

  #include <iostream>
  #define DEBUG

  using namespace std;
    int yylex(void);
    void set_input_string(const char* in);
    void end_lexical_scan(void);
    Program *parse(std::string);
}
%{
  extern "C" int yyparse();
  extern "C" int errors;
  void yyerror (char const *s);
  int errors = 0;
#include "structures/Program.h"
Program* root;
%}
// Tokens

%union {
    char* sval;
    BackTickExpr* backtick_expression;
    Command* command;
    Identifier* identifier;
    Assignable* assignable;
    Node* node;
    PipeExpr* pipe_expression;
    Program* program;
    RedirectionExpr* redirection_expression;
    VariableAssignment* variable_assignment;
    VariableCall* variable_call;
}

%start program_main
%token LAND LOR BAND BOR
%token ASSIGN SC SM GR BT EOL EOFF
%token<sval> IDENTIFIER VARIABLE BT_EXPRESSION

%type <program> program_main
%type <node> proto_program
%type <program> program
%type <command> command
%type <assignable> assignable
%type <variable_assignment> variable_assignment
%type <redirection_expression> redirection_expression
%type <pipe_expression> pipe_expression
%type <backtick_expression> backtick_expression
%type <identifier> identifier
%type <variable_call> variable_call 

%%
program_main            : program EOL {
                            $$ = $1; root = $$;
                            #ifdef DEBUG
                                cout << "1 Program found" << $$->toString() << endl;
                            #endif
                          }
                        | program EOFF {
                            $$ = $1; root = $$;
                            #ifdef DEBUG
                                cout << "2 Program found" << $$->toString() << endl;
                            #endif
                          }
                        ;

program                 : program proto_program {
                            auto commands = $1->getCommands();
                            commands.push_back($2);
                            $1->setCommands(commands);
                            $$ = $1;
                            #ifdef DEBUG
                                cout << "Program found" << $$->toString() << endl;
                            #endif
                          }
                        | proto_program {
                            std::vector<Node*> commands;
                            commands.push_back($1);
                            $$ = new Program(commands);
                          }
                        ;

proto_program           : command {
                            $$ = $1;
                            #ifdef DEBUG
                                cout << "Proto program found: " << $$->toString() << endl;
                            #endif
                          }
                        | pipe_expression { $$ = $1; }
                        | variable_assignment { $$ = $1; }
                        | redirection_expression { $$ = $1; }
                        ;

variable_assignment     : identifier ASSIGN assignable { $$ = new VariableAssignment($1->getIdentifier(), $3); 
                                /* Work with variable values */ }
                        ;

redirection_expression  : redirection_expression GR assignable { $1->setOutput($3); $$ = $1; }
                        | redirection_expression SM assignable { $1->setInput($3); $$ = $1; }
                        | command GR assignable { $$ = new RedirectionExpr($1, nullptr, $3); }
                        | command SM assignable { $$ = new RedirectionExpr($1, $3, nullptr); }
                        ;

pipe_expression         : pipe_expression BOR command { auto pipes = $1->getPipes(); pipes.push_back($3); 
                            $1->setPipes(pipes); $$ = $1; }
                        | command BOR command { std::vector<Node*> pipes; pipes.push_back($1);pipes.push_back($3);
                            $$ = new PipeExpr(pipes); }
                        ;

command                 : command assignable {
                            auto args = $1->getArguments();
                            args.push_back($2);
                            $1->setArguments(args); $$ = $1;
                            #ifdef DEBUG
                                cout << "Command found: " << $$->toString() << endl;
                            #endif
                          }
                        | assignable { std::vector<Node*> args; 
                            $$ = new Command($1, args); }
                        ;

assignable              : backtick_expression { $$ = $1; }
                        | identifier {
                            $$ = $1;
                            #ifdef DEBUG
                                cout << "Assignable found: " << $$->toString() << endl;
                            #endif
                          }
                        | variable_call { $$ = $1; }
                        ;

backtick_expression     : BT program BT {
                            $$ = new BackTickExpr($2);
                            #ifdef DEBUG
                                cout << "Backtick expr found: " << $$->toString() << endl;
                            #endif
                          }
                        ;

identifier              : IDENTIFIER { 
                            $$ = new Identifier(string($1)); 
                            #ifdef DEBUG
                                cout << "Identifier found: " << $$->toString() <<endl;
                            #endif
                          }
                        ;

variable_call           : VARIABLE { 
                            $$ = new VariableCall(string($1)); 
                            #ifdef DEBUG
                                cout << "Variable found: " << $$->toString() <<endl;
                            #endif
                          }
                        ;
%%

void yyerror (char const *s)
{
    errors++;
	//printf("Error: %s\n", s);
}

Program *parse(std::string command)
{
    root = NULL;
    set_input_string(command.c_str());
    yyparse();
    end_lexical_scan();
    cout << endl << endl;
    return root;
}
