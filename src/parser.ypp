%code requires {
  #include "structures/Program.h"
  #include "structures/Pipeline.h"
  #include "structures/Node.h"
  #include "structures/Value.h"
  #include "structures/Command.h"
  #include "structures/Variable.h"
  #include "structures/VarPip.h"

  #include <iostream>
  #include <exception>
  #include <string>
//  #define DEBUG
  #define YYERROR_VERBOSE 1
  using namespace std;

  int yylex(void);
  void set_input_string(const char* in);
  void end_lexical_scan(void);
  Program *parse(std::string);
}
%{
  #include "structures/Program.h"
  #include <stack>


//  extern "C" int yyparse();
  void yyerror (char const *s);
  int errors=0;
  std::stack<Program*> roots;
%}
// Tokens

%union {
    char* sval;
    Command *command;
    Node *node;
    Pipeline *pipeline;
    Program *program;
    Value *value;
    Variable *variable;
    VarPip *varpip;
}

%start program
%token ASSIGN SC SM GR BT EOL EOFF OR EXPORT ERROR
%token<sval> STR BT_EXPRESSION DQ_EXPRESSION

%type<command> command
%type<pipeline> pipeline
%type<program> program
%type<value> value
%type<variable> variable
%type<varpip> varpip

%%
program             : program SC varpip {
                        $$ = $1;
                        $$->varpips.push_back($3);
                      }
                    | varpip {
                        $$ = new Program();
                        roots.push($$);
                        $$->varpips.push_back($1);
                      }
                    ;

varpip              : variable {
                        $$ = $1;
                      }
                    | pipeline {
                        $$ = $1;
                      }
variable            : EXPORT value ASSIGN value {
                        $$ = new Variable(*$2, *$4, true);
                      }
                    | value ASSIGN value {
                        $$ = new Variable(*$1, *$3);
                      }
                    ;

pipeline            : pipeline OR command {
                        $$ = $1;
                        $$->commands.push_back(*$3);
                      }
                    | command {
                        std::vector<Command> cmds = {*$1};
                        $$ = new Pipeline(cmds);
                      }
                    ;

command             : command value {
                        $$ = $1;
                        $$->arguments.push_back(*$2);
                      }
                    | command GR value {
                        $$ = $1;
                        $$->outputFile.push_back(*$3);
                      }
                    | command SM value {
                        $$ = $1;
                        $$->inputFile.push_back(*$3);
                      }
                    | value {
                        $$ = new Command();
                        $$->commandName = *$1;
                      }
                    ;
value               : STR {
                        $$ = new Value($1);
                      }
                    | BT_EXPRESSION {
                        std::string bt_str = string($1);
                        Program * bt_ast = parse(bt_str.substr(1, bt_str.length() - 2));
                        $$ = new Value(bt_ast);
                      }
                    | DQ_EXPRESSION {
                        std::string bt_str = string($1);
                        $$ = new Value(bt_str.substr(1, bt_str.length() - 2));
                      }
                    ;

%%

void yyerror (char const *s)
{
#ifdef DEBUG
    cout << "Error: " << s << endl;
#endif
}


Program *parse(std::string command)
{
    Program *root = nullptr;
    roots.push(root);

    set_input_string(command.c_str());
    yyparse();
    end_lexical_scan();

    if (yynerrs) {
        throw std::runtime_error("Bad request.");
    }

    root = roots.top();
    roots.pop();
    return root;
}
